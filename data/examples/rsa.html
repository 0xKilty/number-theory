<h3>RSA Encryption and Decryption</h3>
<p>
  RSA (Rivest-Shamir-Adleman) is a widely-used public-key encryption algorithm.
  It relies on the practical difficulty of factoring the product of two large
  prime numbers, the "factoring problem", to secure communications. This
  implementation relies on,
  <a href="{{ extended_euclidean }}" target="_blank">extended_euclidean</a> and
  <a href="{{ mod_exp }}" target="_blank">mod_exp</a> from the number-theory
  codebase.
</p>
<p>
  This algorithm uses a couple of different variables \( N = pq \) where \( p \)
  and \( q \) are large primes. Then, \( e \) and \( d \) where \( de \equiv 1
  \mod (p-1)(q-1) \). Finally, \( m \), which represents the message, and \( c
  \) which represents the ciphertext.
</p>
<p>
  To encrypt the message \( c \equiv m^e \mod N \)<br>
  To decrypt the ciphertext \( m \equiv c^d \mod N \)<br>
</p>
<div class="sage">
  <script type="text/x-sage">
def extended_euclidean(a: int, b: int) -> tuple[int, int, int]:
    x_prev, x, y_prev, y = 0, 1, 1, 0
    while b != 0:
        quotient = a // b
        a, b = b, a % b
        x_prev, x = x - quotient * x_prev, x_prev
        y_prev, y = y - quotient * y_prev, y_prev
    return x, y, a

def mod_exp(a: int, b: int, m: int) -> int:
    res = 1
    a %= m
    while b > 0:
        if b & 1:
            res = (res * a) % m
        b >>= 1
        a = (a * a) % m
    return res

def rsa_encrypt(N: int, e: int, m: int) -> int:
    return mod_exp(m,e,N)

def rsa_decrypt(p: int, q: int, e: int, c: int) -> int:
    d = extended_euclidean(e, (p-1)*(q-1))[0]
    return mod_exp(c,d,p*q)

p = 1223
q = 1987
N = p * q
encryption_key = 948047
message = 1070777

print("Original message:", message)

cipher_text = rsa_encrypt(N, encryption_key, message)

print("Cipher text:", cipher_text)

# 1223, 1987 are the prime factors of N
decrypted_message = rsa_decrypt(p, q, encryption_key, cipher_text)

print("Decrypted message:", decrypted_message)
  </script>
</div>
