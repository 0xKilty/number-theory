<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- MathJax -->
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- SageMath -->
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
    <link rel="stylesheet" type="text/css" href="https://sagecell.sagemath.org/static/sagecell_embed.css">
    <script>sagecell.makeSagecell({"inputLocation": ".sage"});</script>

    <link rel="stylesheet" href="/number-theory/styles.css">
    <script src="/number-theory/scripts.js"></script>

    <script>past_color()</script>
    <title>Number Theory</title>
</head>

<body>
    <h1><a href="/number-theory/">\( (n, t) \) Number Theory</a></h1>
    <div class="nav">
        <a href="/number-theory/examples/">Examples</a>
        <a href="/number-theory/directory/">Directory</a>
        <a href="https://pypi.org/project/numbertheory/" target="_blank">PyPi</a>
        <a href="https://github.com/0xKilty/number-theory" target="_blank">Source code</a>
    </div>
    <h3>RSA Encryption and Decryption</h3>
<p>
  RSA (Rivest-Shamir-Adleman) is a widely-used public-key encryption algorithm.
  It relies on the practical difficulty of factoring the product of two large
  prime numbers, the "factoring problem", to secure communications. This
  implementation relies on,
  <a href="https://github.com/0xKilty/number-theory/blob/main/python/numbertheory/common_functions.py#L13" target="_blank">extended_euclidean</a> and
  <a href="https://github.com/0xKilty/number-theory/blob/main/python/numbertheory/common_functions.py#L51" target="_blank">mod_exp</a> from the number-theory
  codebase.
</p>
<p>
  This algorithm uses a couple of different variables \( N = pq \) where \( p \)
  and \( q \) are large primes. Then, \( e \) and \( d \) where \( de \equiv 1
  \mod (p-1)(q-1) \). Finally, \( m \), which represents the message, and \( c
  \) which represents the ciphertext.
</p>
<p>
  To encrypt the message \( c \equiv m^e \mod N \)<br>
  To decrypt the ciphertext \( m \equiv c^d \mod N \)<br>
</p>
<div class="sage">
  <script type="text/x-sage">
def extended_euclidean(a: int, b: int) -> tuple[int, int, int]:
    x_prev, x, y_prev, y = 0, 1, 1, 0
    while b != 0:
        quotient = a // b
        a, b = b, a % b
        x_prev, x = x - quotient * x_prev, x_prev
        y_prev, y = y - quotient * y_prev, y_prev
    return x, y, a

def mod_exp(a: int, b: int, m: int) -> int:
    res = 1
    a %= m
    while b > 0:
        if b & 1:
            res = (res * a) % m
        b >>= 1
        a = (a * a) % m
    return res

def rsa_encrypt(N: int, e: int, m: int) -> int:
    return mod_exp(m,e,N)

def rsa_decrypt(p: int, q: int, e: int, c: int) -> int:
    d = extended_euclidean(e, (p-1)*(q-1))[0]
    return mod_exp(c,d,p*q)

p = 1223
q = 1987
N = p * q
encryption_key = 948047
message = 1070777

print("Original message:", message)

cipher_text = rsa_encrypt(N, encryption_key, message)

print("Cipher text:", cipher_text)

# 1223, 1987 are the prime factors of N
decrypted_message = rsa_decrypt(p, q, encryption_key, cipher_text)

print("Decrypted message:", decrypted_message)
  </script>
</div>
    <div style="margin-bottom: 100px;"></div>
</body>

</html>